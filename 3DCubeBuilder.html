<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="three.js"></script>
    <style type="text/css">
        div#canvas-frame {
            border: none;
            cursor: pointer;
            width: 100%;
            height: 600px;
            background-color: #EEEEEE;
        }
    </style>
    <script>
        var renderer;
        var width;
        var height;
        function initThree() {
            width = document.getElementById('canvas-frame').clientWidth;
            height = document.getElementById('canvas-frame').clientHeight;
            renderer = new THREE.WebGLRenderer({
                antialias : true
            });
            renderer.setSize(width, height);
            document.getElementById('canvas-frame').appendChild(renderer.domElement);
            renderer.setClearColorHex(0xFFFFFF, 1.0);
        };

        var scene;
        function initScene() {
            scene = new THREE.Scene();
        };

        var near;
        var far;
        var aspect;
        var fov;
        var camera;
        function initCamera() {
            near = 1;
            far = 10000;
            aspect = width / height;
            fov = 45;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.updateProjectionMatrix();
            camera.position.set(400,700,400);
            /*camera.position.x = 400;
            camera.position.y = 100;
            camera.position.z = 400;*/
            camera.lookAt({x:0,y:0,z:0});
        };

        var light;
        function initLight() {
            light = new THREE.SpotLight();
            light.position.set( 0, 500, 0 );
            light.intensity = 5;
            scene.add(light);
        };

        /*objects*/
        //var cube;
        var planeGeo;
        function initObject() {
            /*cube = new THREE.Mesh(
                    new THREE.CubeGeometry(50,50,50),
                    new THREE.MeshBasicMaterial({color: 0xFF0000}));
            cube.position.x = 25;
            cube.position.y = 25;
            cube.position.z = 25;
            scene.add(cube);*/

            planeGeo = new THREE.PlaneGeometry(500, 500, 10, 10);
            var planeMat = new THREE.MeshBasicMaterial({color: 0x555555, wireframe: true});
            var plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI/2;
            plane.receiveShadow = true;
            scene.add(plane);
        };

        var projector;
        function initProjector() {
            projector = new THREE.Projector();
        }
        function toScreenXY( world_vector ) {
            var vector = projector.projectVector(world_vector.clone(), camera);
            var halfWidth = width / 2;
            var halfHeight = height / 2;

            //var offset = findOffset(document.getElementById('canvas-frame'));
            var offset = findOffset(renderer.domElement);

            var result = new THREE.Vector3(
                Math.round(vector.x * halfWidth + halfWidth + offset.left),
                Math.round(-vector.y * halfHeight + halfHeight + offset.top),
                vector.z);
            return result;
        }
        function findOffset(element) {
            var pos = new Object();
            pos.left = pos.top = 0;
            if (element.offsetParent)
            {
                do
                {
                    pos.left += element.offsetLeft;
                    pos.top += element.offsetTop;
                } while (element = element.offsetParent);
            }
            return pos;
        }

        var usableCoors;
        function Coors(world_vector, screen_vector) {
            this.world_vector = world_vector;
            this.screen_vector = screen_vector;
        };
        function initCoors() {
            usableCoors = new Array();
            for(i = -225; i <= 225; i += 50) {
                for(j = -225; j <= 225; j += 50) {
                    var cur3 = new THREE.Vector3(i, 0, j);
                    //console.log(cur3);
                    usableCoors.push(new Coors(cur3, toScreenXY(cur3)));
                    //console.log(usableCoors[usableCoors.length-1]);
                }
            }
        };
        function updateCoors() {
            for(var i = 0; i < usableCoors.length; i++) {
                    usableCoors[i].screen_vector = toScreenXY(usableCoors[i].world_vector);
            }
        }

        var render = function(){renderer.render(scene, camera)};
        function threeStart() {
            initThree();
            initCamera();
            initScene();
            initLight();
            initObject();
            renderer.clear();
            render();
            initProjector();
            initCoors();
        };

        /*key pressed event*/
        /*document.onkeydown = onKeyDown;
        function onKeyDown(ev) {
            ev = ev || window.event;
            var keyCode = getKeyCode(ev);
            //document.getElementById("s4").innerHTML = keyCode;
            if(keyCode == 37) {
                var z0 = camera.position.z;
                var x0 = camera.position.x;
                camera.position.z = z0 * Math.cos(Math.PI/180) - x0 * Math.sin(Math.PI/180);
                camera.position.x = z0 * Math.sin(Math.PI/180) + x0 * Math.cos(Math.PI/180);
                camera.lookAt({x:0,y:0,z:0});
                render();
            }
            else if(keyCode == 39) {
                var z0 = camera.position.z;
                var x0 = camera.position.x;
                camera.position.z = z0 * Math.cos(Math.PI/180) + x0 * Math.sin(Math.PI/180);
                camera.position.x = -1 * z0 * Math.sin(Math.PI/180) + x0 * Math.cos(Math.PI/180);
                camera.lookAt({x:0,y:0,z:0});
                render();
            }
            else if(keyCode == 38){
                camera.fov *= 0.95;
                camera.updateProjectionMatrix();
                render();
            }
            else if(keyCode == 40){
                camera.fov /= 0.95;
                camera.updateProjectionMatrix();
                render();
            }
        };
        function getKeyCode(ev)
        {
            var kc;
            if(window.event) // IE
                kc = ev.keyCode;
            else if(ev.which) // Netscape/Firefox/Opera
                kc = ev.which;
            return kc;
        };*/

        /*mouse wheel event*/
        /*注册事件*/
        if(document.addEventListener){
            document.addEventListener('DOMMouseScroll',scrollMove,false);
        }//W3C
        window.onmousewheel=document.onmousewheel = scrollMove;//IE/Opera/Chrome
        function scrollMove(ev) {
            ev = ev || window.event;
            if(ev.wheelDelta){//IE/Opera/Chrome
                document.getElementById("s4").innerHTML = ev.wheelDelta;
                camera.fov *= Math.pow(0.99,ev.wheelDelta/30);
                camera.updateProjectionMatrix();
                render();
            }
            else if(ev.detail){//Firefox
                //t2.value=ev.detail;
            }
            //updateCoors();
        }
        /*mouse drug event*/
        var cameraX = 0, cameraY = 0;
        var mouseDowning = 0;
        document.onmousemove = mouseMove;
        function mouseMove(ev){
            ev = ev || window.event;
            var mousePos = mouseCoords(ev);
            var offX = mousePos.x - cameraX;
            var offY = mousePos.y - cameraY;
            cameraX = mousePos.x;
            cameraY = mousePos.y;
            document.getElementById("s1").innerHTML = cameraX;
            document.getElementById("s2").innerHTML = cameraY;
            if(mouseDowning == 1) {
                document.getElementById("s3").innerHTML = "pressing";
                var angle = Math.abs(offX)/10 * Math.PI/180;
                if(offX > 0) {
                    var z0 = camera.position.z;
                    var x0 = camera.position.x;
                    camera.position.z = z0 * Math.cos(angle) + x0 * Math.sin(angle);
                    camera.position.x = -1 * z0 * Math.sin(angle) + x0 * Math.cos(angle);
                    camera.lookAt({x:0,y:0,z:0});
                    render();
                }
                else if(offX < 0){
                    var z0 = camera.position.z;
                    var x0 = camera.position.x;
                    camera.position.z = z0 * Math.cos(angle) - x0 * Math.sin(angle);
                    camera.position.x = z0 * Math.sin(angle) + x0 * Math.cos(angle);
                    camera.lookAt({x:0,y:0,z:0});
                    render();
                }
                else ;
            }
            else {
                document.getElementById("s3").innerHTML = "unpressing";
            }
        };
        function mouseCoords(ev){
            if(ev.pageX || ev.pageY){
                return {x:ev.pageX, y:ev.pageY};
            }
            return {
                x:ev.clientX + document.body.scrollLeft - document.body.clientLeft,
                y:ev.clientY + document.body.scrollTop  - document.body.clientTop
            };
        };
        document.onmousedown = mouseDown;
        var downTime = null;
        function mouseDown(ev){
            ev = ev || window.event;
            mouseDowning = 1;
            downTime = new Date();
        };
        document.onmouseup = mouseUp;
        function mouseUp(ev){
            ev = ev || window.event;
            mouseDowning = 0;
            //updateCoors();
        };
        document.onclick = mouseClick;
        function mouseClick(ev) {
            ev = ev || window.event;
            var t = new Date();
            if(t.getTime() - downTime.getTime() > 100) {
                mouseDowning  = 0;
                downTime = null;
                return ;
            }
            var mousePos = mouseCoords(ev);
            document.getElementById("s4").innerHTML = "click";
            updateCoors();
            console.log(usableCoors);
            var insidePlanes = new Array();
            var insidePlane = new Coors(new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0));
            for(var i = 0; i < usableCoors.length; i++) {
                if(usableCoors[i].world_vector.x % 50 != 0 && usableCoors[i].world_vector.z % 50 != 0) {
                    //center point of horizontal planes which can be placed with cube
                    /*
                     ---------------> X
                     |   p1--------------->p2
                     |       world_vector
                     |   p4<---------------p3
                    \|/ Z
                    * */
                    var p1 = new THREE.Vector3(
                            usableCoors[i].world_vector.x-25,
                            usableCoors[i].world_vector.y,
                            usableCoors[i].world_vector.z-25
                    );
                    var p2 = new THREE.Vector3(
                            usableCoors[i].world_vector.x+25,
                            usableCoors[i].world_vector.y,
                            usableCoors[i].world_vector.z-25
                    );
                    var p3 = new THREE.Vector3(
                            usableCoors[i].world_vector.x+25,
                            usableCoors[i].world_vector.y,
                            usableCoors[i].world_vector.z+25
                    );
                    var p4 = new THREE.Vector3(
                            usableCoors[i].world_vector.x-25,
                            usableCoors[i].world_vector.y,
                            usableCoors[i].world_vector.z+25
                    );
                    var sp1 = toScreenXY(p1);
                    var sp2 = toScreenXY(p2);
                    var sp3 = toScreenXY(p3);
                    var sp4 = toScreenXY(p4);
                    var mousePos3 = new THREE.Vector3(mousePos.x, mousePos.y, 0);

                    var sp12 = new THREE.Vector3().subVectors(sp2, sp1);
                    var sp1m = new THREE.Vector3().subVectors(mousePos, sp1);
                    var sp23 = new THREE.Vector3().subVectors(sp3, sp2);
                    var sp2m = new THREE.Vector3().subVectors(mousePos, sp2);
                    var sp34 = new THREE.Vector3().subVectors(sp4, sp3);
                    var sp3m = new THREE.Vector3().subVectors(mousePos, sp3);
                    var sp41 = new THREE.Vector3().subVectors(sp1, sp4);
                    var sp4m = new THREE.Vector3().subVectors(mousePos, sp4);
                    if(crossVector2(sp12, sp1m) > 0 && crossVector2(sp23, sp2m) > 0
                            && crossVector2(sp34, sp3m) > 0 && crossVector2(sp41, sp4m) > 0) {
                        insidePlanes.push(usableCoors[i]);
                    }
                }
                else {
                    //center point of vertical planes which can be placed with cube
                }
            }
            if(insidePlanes.length > 0) {
                insidePlane = insidePlanes[0];
                for(var i = 1; i < insidePlanes.length; i++) {
                    if(insidePlane.screen_vector.z < insidePlanes[i].screen_vector.z) {
                        insidePlane = insidePlanes[i];
                    }
                }
            }
            if(insidePlane.world_vector.x == 0 && insidePlane.world_vector.y == 0 && insidePlane.world_vector.z == 0) ;
            else {
                if(insidePlane.world_vector.x % 50 != 0 && insidePlane.world_vector.z % 50 != 0) {
                    var cube = new THREE.Mesh(
                            new THREE.CubeGeometry(50,50,50),
                            new THREE.MeshLambertMaterial({color: 0x0000ff}));
                    cube.position.x = insidePlane.world_vector.x;
                    cube.position.y = insidePlane.world_vector.y + 25;
                    cube.position.z = insidePlane.world_vector.z;
                    scene.add(cube);
                    renderer.clear();
                    render();
                }
            }
            mouseDowning = 0;
        };
        function crossVector2(v1, v2) {
            return v1.x*v2.y - v1.y*v2.x;
        };
    </script>
</head>
<body onload="threeStart();">
<div id="canvas-frame"></div>
<!--<p>press '<-' or '->' to rotate the visual angle</p>
<p>press UpArrow or DownArrow to zoom</p>
<p>press 'a' to place a cube</p>-->
<span id="s1"></span>
<span id="s2"></span>
<span id="s3"></span>
<span id="s4"></span>
</body>
</html>
